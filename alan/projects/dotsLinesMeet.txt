<span style="font-size: 20px;">Search for the Intersection of Two Lines</span><br />by Ted Kaehler<br /><br /><br />In the previous chapter of the<span style="font-size: 13px;"> <a href="#dotsPuzzle">Nine Dots Puzzle</a>, </span>we realized that we need to find the intersection of two lines.&nbsp; Since this essay is about artificial evolution, let's use that hammer to solve this problem also. <br /><br />Yes, there is a formula for the exact intersection of two lines, but I certainly can't remember what it is.&nbsp; Understanding how that formula was derived is even more complex.&nbsp; We don't need a formula.&nbsp; We can simply define an error function, guess an answer, and start hillclimbing toward the true answer.<br /><br />If we express a line in parameterized form, then purely vertical or purely horizontal lines will not give us any trouble.&nbsp; There will be no annoying division by zero.<br /><pre>/* Basic arithmetic functions for vector operation */<br />Array.prototype.plus = function(anArray) {<br /> return [this[0] + anArray[0], this[1] + anArray[1]]<br />}<br />Array.prototype.minus = function(anArray) {<br /> return [this[0] - anArray[0], this[1] - anArray[1]]<br />}<br />Array.prototype.times= function(aNumber) {<br /> return [this[0] * aNumber, this[1] * aNumber]<br />}<br />Array.prototype.dotProduct = function(anArray) {<br /> return this[0] * anArray[0] + this[1] * anArray[1]<br />}<br /><br />[1,2].plus([3,4])<br />[1,2].times(2.5)<br />[1,2].dotProduct([-2,1]) /* =&gt; 0 */<br /></pre>a point on the line = origin + (parameter * ratio)<br /><br />where origin is a known point on the line, parameter is a number, and ratio is an (x,y) pair.&nbsp; Multiplication and addition a defined in class Point in Smalltalk, which represents an (x,y) pair.<br /><br /><span style="font-size: 18px;">Strategy</span><br /><br />Let's set up two parameterized lines, one for each segment, and search for the intersection point.&nbsp; We are looking for parameter values that make a point on one line very close to a point on the other line.&nbsp; Let t1 be the parameter for one line, and t2 for the other.&nbsp; The error is the distance between these points:<br /><br />distance vector = dvec =&nbsp; origin1 + (t1*ratio1)&nbsp; -&nbsp; origin2 + (t2*ratio2)<br /><br />distance = squareRoot ( dvec dotProduct: dvec )<br /><br />We will use the distance squared as the error, since it is faster to compute.&nbsp; We will hunt for t1 and t2 that minimize this error.&nbsp; (The dot product is x1*x2 + y1*y2.)<br /><br />error = dvec dotProduct: dvec<br /><br /><br /><span style="font-size: 18px;">A Parameterized Line</span><br /><br />We define objects of class LineParameterized to have two instance variables, origin and ratio.<br /><pre>// Object subclass: #LineParameterized<br />// 	instanceVariableNames: 'origin ratio'<br />// 	classVariableNames: ''<br />// 	poolDictionaries: ''<br />// 	category: 'Active-Essay'<br /></pre>From two points on the line, we need to compute and remember the ratio.&nbsp; Here is the definition of a method to do that.<br />
<pre>LineParameterized = function(pt1, other) {<br /> this.origin = pt1<br /> this.ratio = other.minus(pt1)<br />}<br />LineParameterized.prototype.toString = function() {<br /> return "{origin: " + this.origin + " ratio: " + this.ratio + "}"<br />}<br /><span class="objectBox objectBox-text">line0 = new LineParameterized([1,1], [2,2])</span><br /><span class="objectBox objectBox-text"><br /></span><strong>// origin: pt1 to: other</strong><br />// 	origin := pt1.<br />//	ratio := other - origin.<br /></pre>
Given a parameter value, return a point on the line:<br /><pre><span class="objectBox objectBox-text">LineParameterized.prototype.pointAt = function(parameter)</span> {<br /> /* Return a point on the line for this parameter */<br /> return this.origin.plus(this.ratio.times(<span class="objectBox objectBox-text">parameter</span>))<br />}<br />line0.pointAt(2) /* =&gt; [3, 3] */<br /><br /><strong>// pointAt: parameter</strong><br />// 	"Return a point on the line for this parameter"<br />// 	^ origin + (parameter * ratio)<br /></pre><span style="font-size: 18px;">A Parameterized Line for Hill Climbing<br /></span><br />Let's define a subclass that remembers the parameter and a delta for how fast we are moving the parameter.&nbsp; Delta remembers the most recent successful move of the parameter, including the direction and the amount.<br /><br /><pre>LineHunting = function(pt1, other) {<br /><span class="objectBox objectBox-text"> LineParameterized.call(this, pt1, other)<br /></span>&nbsp; this.param = 0<br /> this.delta = 0<br />}<br />LineHunting.prototype = new <span class="objectBox objectBox-text">LineParameterized([0,0], [0,0])</span><br />LineHunting.prototype.toString = function() {<br /> return "{origin: " + this.origin + ", ratio: " + this.ratio +<br /> ", param: " + this.param + ", delta: " + this.delta + "}"<br />}<br />line0 = new LineHunting([2,1], [2,2])<br /><br />// LineParameterized subclass: #LineHunting<br />// 	instanceVariableNames: 'param delta'<br />// 	classVariableNames: ''<br />// 	poolDictionaries: ''<br />//	category: 'Active-Essay'<br /></pre>We need to be able to read and write into the value of the parameter and the delta.&nbsp;&nbsp; Here are the four accessor methods.<br />
<pre><strong>// delta</strong><br />// 	^ delta<strong><br />//<br />// delta: anObject</strong><br />// 	"Set the value of delta"<br />// 	delta := anObject<strong><br />// <br />// param</strong><br />// 	^ param<br />// <br />// <strong>param: anObject</strong><br />// 	"Set the value of param"<br />// 	param := anObject<br /></pre>
<br /><span style="font-size: 18px;">An Object Holding the Intersection of Two Lines</span><br /><br />Let's define an object that represents the corner of two line segments.&nbsp; We will use it in the solution array instead of 'turn'.&nbsp; It has two instance variables.&nbsp; 'line1' is the segment before the corner and 'line2' is the one after it.<br /><pre>LineIntersection = function(line1, line2) {<br /> line1.param = 0<br /> line1.delta = 5<br /> this.line1 = line1<br /> line2.param = 0<br /> line2.delta = 5<br /> this.line2 = line2<br />}<br />LineIntersection.prototype.toString = function() {<br /> return "{line1: " + this.line1.toString() +<br /> ", line2: " + this.line2.toString() + "}"<br />}<br /><br />inters0 = new LineIntersection(new LineHunting([0,0], [1,0]),<br />  new LineHunting([2,1], [2,2]))<br /><br />// Object subclass: #LineIntersection<br />// 	instanceVariableNames: 'line1 line2'<br />// 	classVariableNames: ''<br />// 	poolDictionaries: ''<br />// 	category: 'Active-Essay'<br /></pre>When we initialize line1 and line2, they will not know their intersection point. Our goal is to change the param of each line to make the point at param be the intersection.&nbsp; <br /><br />We will change param in various directions.&nbsp; If the distance between the two intersection points is smaller, we will keep the change.&nbsp; The distance squared is computed by this method:<br /><pre>LineIntersection.prototype.errorSquared = function() {<br /> var delta = this.line1.pointAt(this.line1.param).minus(<br /> this.line2.pointAt(this.line2.param))<br /> return delta.dotProduct(delta)<br />}<br /><br />inters0.errorSquared() /* =&gt; 5 */<br /><strong><br />// errorSquared</strong><br />//	"the current error in the intersection point"<br />//	| delta |<br />//	delta := (line1 pointAt: line1 param) - <br />//		(line2 pointAt: line2 param).<br />//	^ delta dotProduct: delta<br /></pre>Rather than just trying different values of param randomly, we will keep the last change in param.&nbsp; It worked, so maybe a change of that magnitude and direction will work again.&nbsp; The change in param is kept in the lines's delta.&nbsp; <br /><br />Param corresponds to a postion on the line.&nbsp; Delta corresponds to a velocity.&nbsp; We will try different accelerations, called accel, in this method:<br /><pre>LineIntersection.prototype.changeDelta = function(accel, aLine) {<br /> var oldErr = this.errorSquared()<br /> var oldP1 = aLine.param<br /> var oldD = aLine.delta<br /> aLine.delta = aLine.delta * accel<br /> aLine.param = aLine.param + aLine.delta<br /> if (this.errorSquared() &lt; oldErr) return true<br /> aLine.param = oldP1 /* put it back */<br /> aLine.delta = oldD /* put it back */<br /> return false<br />}<br /><br />inters0.changeDelta(0.1, inters0.line1)<br />inters0.line1 /* =&gt; {origin: [0, 0], ratio: [1, 0], param: 0.5, delta: 0.5} */<br /><br />// <strong>changeDelta: accel forLine: aLine</strong><br />// 	"Change the change in param and see if it works."<br />// 	| oldErr oldP1 oldD |<br />// 	oldErr := self errorSquared.<br />// 	oldP1 := aLine param.<br />// 	oldD := aLine delta.<br />// 	aLine delta: aLine delta * accel.<br />// 	aLine param: aLine param + aLine delta.<br />// 	self errorSquared &lt; oldErr ifTrue: [^ true].<br />// 	aLine param: oldP1.	"put it back"<br />// 	aLine delta: oldD.	"put it back"<br />// 	^ false<br /></pre>This method uses accel to make a new delta and uses that to move param.&nbsp; If the new errorSquared is less than before, keep the new delta and param.&nbsp; If not, revert to the old values.&nbsp; Return true if progress was made.&nbsp; We are varying the point on one line and holding constant the proposed intersection point on the other line.<br /><br />What values of acceleration should we try?&nbsp; <br />2 = move param twice as far as before.<br />1 = move param again the same amount as before.<br />-1 = reverse direction (very useful just after the initial guess for delta).<br />0.33 = forward at one third speed.<br />0.005 = creep forward in case we are making changes that are grossly too big.<br />-0.005 = creep backwards.&nbsp; Did we overshoot?<br /><br />Loop through the accelerations and look for one that moves the point on the line to a place with a smaller error.&nbsp; <br /><pre>LineIntersection.prototype._makeProgress = function(aLine) {<br /> /* Vary params to try to get closer to the intersection. <br /> Try to reduce the error. Return true if made progress. */<br /> var tryAccels = [2, 1, -1, 0.33, 0.005, -0.005]<br /> for (var i = 0; i &lt; tryAccels.length; i++) {<br /> if (this.changeDelta(tryAccels[i], aLine)) return true<br /> }<br /> return false<br />}<br /><br />inters0 = new LineIntersection(new LineHunting([0,0], [1,0]),<br />  new LineHunting([2,1], [2,2]))<br />inters0._makeProgress(inters0.line1)<br />inters0.line1<br /><br />// <strong>makeProgress: aLine</strong><br />// 	"Vary params to try to get closer to the intersection. <br />// Try to reduce the error. Return true if made progress."<br />// #(2 1 -1 0.33 0.005 -0.005) do: [:tryAccel |<br />// 	(self changeDelta: tryAccel forLine: aLine) <br />// 		ifTrue: [^ true]].<br />// ^ false<br /></pre>Of course to get&nbsp; the intersection point, we need to adjust the param on each of the two lines.<br /><pre>LineIntersection.prototype.makeProgress = function() {<br /> /* Try to get closer to a good intersection on each line. <br /> Return true if made progress. */<br /> var b1 = this._makeProgress(this.line1)<br /> var b2 = this._makeProgress(this.line2)<br /> return b1 || b2<br />}<br /><br />inters0 = new LineIntersection(new LineHunting([0,0], [1,0]),<br />  new LineHunting([2,1], [2,2]))<br />inters0.makeProgress()<br /><br />// <strong>makeProgress</strong><br />// 	"Try to get closer to a good intersection on each line. <br />// Return true if made progress."<br />// 	| b1 b2 |<br />// 	b1 _ self makeProgress: line1.<br />// 	b2 _ self makeProgress: line2.<br />// 	^ b1 | b2	"force both to evaluate"<br /></pre>See if the error is small enough, and try one round of moving params if it is not.&nbsp; This is the method that the Nine Dots solver will call repeatedly to find the actual intersection point.&nbsp; When the error is low enough, the intersection point is (line1 pointAt: line1 param).<br /><pre>LineIntersection.prototype.tryForError = function(anError) {<br /> /* Return #parallel if can't make any progress. <br /> Try to reduce the error in the intersection point of the <br /> two lines. Return true if we got under goal error. */<br /><br /> if (this.errorSquared() &lt; anError) return true<br /> if (this.makeProgress()) {<br /> return this.errorSquared() &lt; anError<br /> } else {<br /> return "parallel"<br /> }<br />}<br />inters0 = new LineIntersection(<br /> new LineHunting([0,0], [1,0]),<br /> new LineHunting([1,0], [2,0]))<br />inters0.tryForError(0.09) /* == "pararell" */ /* it looks a bug... */<br />inters0<br /><br />// <strong>tryForError: anError</strong><br />// 	"Return #parallel if can't make any progress. <br />// Try to reduce the error in the intersection point of the <br />// two lines. Return true if we got under goal error."<br />// <br />// 	self errorSquared &lt; anError ifTrue: [^ true].<br />// 	^ self makeProgress<br />// 		ifTrue: [self errorSquared &lt; anError]<br />// 		ifFalse: [#parallel]<br /></pre>We need to store the lines and initialize param and delta.<br /><pre>// (these accessors were defined the constructor of LineIntersection in JS)<br />// <br />// <strong>line1: anObject</strong><br />// 	line1 _ anObject.<br />// 	line1 param: 0.<br />// 	line1 delta: 5.<br />// <br />// <strong>line2: anObject</strong><br />// 	line2 _ anObject.<br />// 	line2 param: 0.<br />// 	line2 delta: 5.<br /></pre>And here are access methods for the lines.<br /><pre>// <strong>line1</strong><br />// 	^ line1<br />// <br />// <strong>line2</strong><br />// 	^ line2<br /></pre><span style="font-size: 18px;">Testing</span><br /><br />Here is some test code to make two lines and try to find the intersection.<br /><pre>inters = new LineIntersection(<br /> new LineHunting([0,0], [1,0]),<br /> new LineHunting([2,1], [2,2]))<br />while(inters.tryForError(0.09) == false)<br />inters.line1.pointAt(inters.line1.param) /* =&gt; almost [2, 0] */<br /><br />// | inters |<br />// inters := LineIntersection new.<br />// inters line1: (LineHunting new origin: (0@0) to: (1@0)).<br />// inters line2: (LineHunting new origin: (2@1) to: (2@2)).<br />// [(inters tryForError: 0.09) == true] whileFalse.<br /></pre>Here are the two lines, and the candidate intersection points that makeProgress discovered.&nbsp; The vertical line is <strong>not</strong> the Y axis.&nbsp; There is no red mark at the intersection because we stopped when the distance was less than 0.3 units.<br /><br /><img  alt="http://tinlizzie.org/ometa-js/alan/projects/lines-inter-steps.gif" src="http://tinlizzie.org/ometa-js/alan/projects/lines-inter-steps.gif" /><br /><br /><br />To do:<br />refineEnds<br />
<br />links back and forward.